<!DOCTYPE html><html><head><link href="/styles.css" rel="stylesheet" /></head><body><article><h1>Hands on <code>data.table</code></h1><p>The <code>data.table</code> package introduces "enhanced" data frames, concise syntax, and fast data processing, so let's learn about it!</p><p>I won't give any more introductions except that this tutorial is mostly based on the package's introductory vignette, but I will include some of my own observations and opinions as well. You could find the vignette <a href='https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html'>here</a> or you could load it (after installing the package) with this command:</p><pre><code class="r">vignette&#40;&quot;datatable-intro&quot;&#41;
</code></pre><p>Let's get started!</p><h2>Creating <code>data.table</code>s</h2><p>Before working on <code>data.table</code> objects, let's explore the methods we can use to create one.</p><h3>Reading from a file/URL</h3><p>The function <code>fread&#40;&#41;</code> allows you to read from local files (e.g. CSV) or external URLs.</p><pre><code class="r">flights &lt;- fread&#40;&quot;flights14.csv&quot;&#41;
</code></pre><h3>Building it manually</h3><p>Creating a <code>data.table</code> here is almost identical to creating base R's data frames, except that the function is named <code>data.table&#40;&#41;</code> instead of <code>data.frame&#40;&#41;</code>.</p><pre><code class="r">my&#95;dt &lt;- data.table&#40;
  id = c&#40;&quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;c&quot;&#41;,
  a  = 1:6,
  b  = 7:12,
  c  = 13:18
&#41;

my&#95;dt
#    id a  b  c
# 1:  b 1  7 13
# 2:  b 2  8 14
# 3:  b 3  9 15
# 4:  a 4 10 16
# 5:  a 5 11 17
# 6:  c 6 12 18
</code></pre><h3>Converting an existing data frame</h3><p>The function <code>data.table&#40;&#41;</code> mentioned earlier can be given a data frame to be converted to a <code>data.table</code> object. It's that simple!</p><p>However, There is another function that is a little bit tricky because R usually doesn't work that way. That function is <code>setDT&#40;&#41;</code>.  The tricky part is that it <i>modifies</i> (or mutates) the existing object. It doesn't return a new object for you to assign somewhere. It doesn't return anything! Because of that, you cannot use <code>setDT&#40;&#41;</code> on an built-in data frame (e.g. <code>iris</code>, <code>mtcars</code>) unless you assign it into a variable in your environment.</p><pre><code class="r">iris&#95;df &lt;- iris
setDT&#40;iris&#95;df&#41; # same as `iris&#95;df &lt;- data.table&#40;iris&#95;df&#41;`
</code></pre><h2>Subsetting <code>data.table</code>s</h2><p>First of all, since a <code>data.table</code> are "enhanced" version of the conventional data frame, basic functions that work on data frames still work on <code>data.table</code>s. Also, string columns don't get automatically converted to factors (which <i>was</i> the default behavior in base R pre-version 4.0).</p><pre><code class="r">class&#40;my&#95;dt&#41;
# &#91;1&#93; &quot;data.table&quot; &quot;data.frame&quot;

summary&#40;my&#95;dt&#41;
#       id                  a              b               c
#  Length:6           Min.   :1.00   Min.   : 7.00   Min.   :13.00
#  Class :character   1st Qu.:2.25   1st Qu.: 8.25   1st Qu.:14.25
#  Mode  :character   Median :3.50   Median : 9.50   Median :15.50
#                     Mean   :3.50   Mean   : 9.50   Mean   :15.50
#                     3rd Qu.:4.75   3rd Qu.:10.75   3rd Qu.:16.75
#                     Max.   :6.00   Max.   :12.00   Max.   :18.00
</code></pre><p>The square-bracket subsetting syntax <code>&#91;&#93;</code> is what encloses the special <code>data.table</code> syntax. So, its basic premise is the same as base R. But <code>data.table</code> adds a lot of features on that syntax.</p><h3>Subsetting rows</h3><p>Subsetting rows with <code>data.table</code> is exactly the same as base R's subsetting, except that <i>the comma is optional</i> if no columns are chosen.</p><pre><code class="r">my&#95;dt&#91; c&#40;1, 4, 6&#41; &#93; # same as `my&#95;dt&#91; c&#40;1, 4, 6&#41;, &#93;`
#    id a  b  c
# 1:  b 1  7 13
# 2:  a 4 10 16
# 3:  c 6 12 18

my&#95;dt&#91; id == &quot;a&quot; &#93;
#    id a  b  c
# 1:  a 4 10 16
# 2:  a 5 11 17
</code></pre><p>Although this indexing method is usually meant for subsetting, you could actually use it to <i>order</i> your table by some column. This is not special to <code>data.table</code>, but it is kind of a neat trick.</p><pre><code class="r">my&#95;dt&#91; order&#40;id&#41; &#93;
#    id a  b  c
# 1:  a 4 10 16
# 2:  a 5 11 17
# 3:  b 1  7 13
# 4:  b 2  8 14
# 5:  b 3  9 15
# 6:  c 6 12 18
</code></pre><h3>Subsetting columns</h3><p>Again, the syntax here is similar to base R. But there are additional points to be considered.</p><ul><li>The variable names are used without quotation marks.<pre><code class="r">my&#95;dt&#91; , c &#93;
# &#91;1&#93; 13 14 15 16 17 18
</code></pre></li><li>The default behavior of 1-column subsets is to be converted to a vector  (instead of 1-column <code>data.table</code>) unless that variable is wrapped in  <code>list&#40;&#41;</code>.  Also, there is an alias for <code>list&#40;&#41;</code> to be used in <code>data.table</code>  syntax, and that alias is <code>.&#40;&#41;</code> -- a dot instead of <code>list</code>.<pre><code class="r">my&#95;dt&#91; , .&#40;a&#41; &#93; # same as `my&#95;dt&#91; , list&#40;a&#41; &#93;`
#    a
# 1: 1
# 2: 2
# 3: 3
# 4: 4
# 5: 5
# 6: 6
</code></pre></li><li>The <code>.&#40;&#41;</code>/<code>list&#40;&#41;</code> syntax can be used to subset multiple columns.<pre><code class="r">my&#95;dt&#91; , .&#40;a, c&#41; &#93;
#    a  c
# 1: 1 13
# 2: 2 14
# 3: 3 15
# 4: 4 16
# 5: 5 17
# 6: 6 18
</code></pre></li><li>Named lists can be used in <code>.&#40;&#41;</code>/<code>list&#40;&#41;</code> to rename columns.<pre><code class="r">my&#95;dt&#91; , .&#40;col&#95;a = a, col&#95;c = c&#41; &#93;
#    col&#95;a col&#95;c
# 1:     1    13
# 2:     2    14
# 3:     3    15
# 4:     4    16
# 5:     5    17
# 6:     6    18
</code></pre></li></ul><p>Here is some additional column-subsetting syntax:</p><ul><li>The conventional base R way (with a character vector):<ul><li><code>my&#95;dt&#91; , c&#40;&quot;arr&#95;delay&quot;, &quot;dep&#95;delay&quot;&#41; &#93;</code></li></ul></li><li>Selecting columns using column names stored in a variable with <code>..</code>:<ul><li><code>my&#95;dt&#91; , ..variable&#95;with&#95;names &#93;</code></li></ul></li><li>Deselecting columns with <code>!</code> or <code>-</code>:<ul><li><code>my&#95;dt&#91; , !c&#40;&quot;a&quot;, &quot;c&quot;&#41; &#93;</code></li><li><code>my&#95;dt&#91; , !..variable&#95;with&#95;names &#93;</code></li><li><code>my&#95;dt&#91; , -..variable&#95;with&#95;names &#93;</code></li></ul></li></ul><h2>Aggregation</h2><p>This is where things get more interesting. Within the same pair of brackets, you could actually perform aggregation (summary statistics). Of course, this operation can be combined with row-subsetting.</p><pre><code class="r">my&#95;dt&#91; , sum&#40;a&#41; &#93;
# &#91;1&#93; 21

my&#95;dt&#91; , .&#40;mean&#95;a = mean&#40;a&#41;, mean&#95;b = mean&#40;b&#41;&#41; &#93;
#    mean&#95;a mean&#95;b
# 1:    3.5    9.5

my&#95;dt&#91; id == &quot;b&quot;, .&#40;mean&#95;a = mean&#40;a&#41;, mean&#95;b = mean&#40;b&#41;&#41; &#93;
#    mean&#95;a mean&#95;b
# 1:      2      8
</code></pre><p>There is a special symbol <code>.N</code> which gets the number of rows/sample size.</p><pre><code class="r">my&#95;dt&#91; a &gt;= 3, .N &#93;
# &#91;1&#93; 4
</code></pre><p>Aggregation is most useful when it is grouped, and this is where we take <code>data.table</code>'s syntax to an even higher level: there is a <code>by=</code> argument that we can use also inside the square brackets. This argument takes a variable name or multiple names with the same <code>.&#40;&#41;</code>/<code>list&#40;&#41;</code> syntax.</p><pre><code class="r">my&#95;dt&#91; , .N, by = .&#40;id&#41; &#93; # same as `my&#95;dt&#91; , .N, id &#93;`
#    id N
# 1:  b 3
# 2:  a 2
# 3:  c 1
</code></pre><p>Instead of <code>by=</code> There is another argument named <code>keyby=</code> which actually sorts the groups.</p><pre><code class="r">my&#95;dt&#91; , .N, keyby= id &#93;
#    id N
# 1:  a 2
# 2:  b 3
# 3:  c 1
</code></pre><h2>Chaining <code>data.table</code> operations</h2><p>So far, we have been discussing operations that have matching "verbs" in <code>dplyr</code> (e.g. <code>filter&#40;&#41;</code>, <code>select&#40;&#41;</code>, <code>summarize&#40;&#41;</code>, <code>group&#95;by&#40;&#41;</code>). But there is another important feature: chaining operations (for which <code>dplyr</code> uses the pipe operator <code>%&gt;%</code>). So can we chain operations in <code>data.table</code> code?</p><p>The answer is yes. Actually, it requires no additional syntax if you think about the following logic: </p><ol><li>The operation starts with a <code>data.table</code> object followed by square-bracket   syntax.</li><li>The output of that operation is also a <code>data.table</code> object, which (you   might have noticed) is also the starting point of step 1!   </li></ol><p>After performing one operation on a <code>data.table</code>, a new operation can be added <i>directly after the previous one</i> with no need for intermediate variables or even special operators like the pipe.</p><p>In the next example, I made the same operation from the previous example, which had a column <code>N</code>. Then, I used that <code>N</code> column in a new subsetting operation.</p><pre><code class="r">my&#95;dt&#91; , .N, keyby = id &#93;&#91; N &gt; 1 &#93;
#    id N
# 1:  a 2
# 2:  b 3
</code></pre><h2>Other perks of <code>data.table</code></h2><p>So far, the whole tutorial has been about the syntax of making and working with <code>data.table</code>s, now let me describe some othe features and advantages for using the package:</p><ul><li>Operations are optimized for speed in both reading and manipulating data. This  makes <code>data.table</code> quite popular among those who work with big datasets or  care about the speed of their programs in general.</li><li>When printing long tables, column names do not only print at the top, but also  at the bottom. You will be spared a couple of mouse scrolls.</li><li>There is a little detail that I find quite nice: if you call <code>fread&#40;&#41;</code> trying  to import a local file and it couldn't find the file, it raises the error but  also prints the current working directory. I usually forget to check the  working directory, so I find that quite helpful.</li><li>If you haven't noticed, the syntax is quite concise. You could do so much in  one line.</li></ul><h2>My personal comments</h2><p>I think <code>data.table</code> is quite an interesting package, and the next points sum up my own opinions after getting started with the package along with some comparisons to its popular counterpart <code>dplyr</code>.</p><ul><li><strong>Philosophy</strong>: this package's syntax and style feel like an extension to base  R's syntax. This is different from the <code>dplyr</code> which changes the style of R  code into something that is more English-like and more verbose, which takes us  to the next point...</li><li><strong>Conciseness</strong>: I honestly love concise code. It feels like a powerful thing  to be able to semantically produce very much with as little code as possible,  which is why <code>data.table</code> is quite interesting to me. Look at these two pieces  of code for doing the same set of operations in both <code>data.table</code> syntax and  <code>dplyr</code> syntax, assuming I start with a base R data frame and convert it to  the corresponding package's object type before proceeding.<pre><code class="r"># data.table
data.table&#40;mtcars&#41;&#91; am == 1, .&#40;mmpg = mean&#40;mpg&#41;&#41;, by = cyl &#93;&#91; order&#40;mmpg&#41; &#93;

# dplyr
tibble&#40;mtcars&#41; %&gt;% filter&#40;am == 1&#41; %&gt;% group&#95;by&#40;cyl&#41; %&gt;% summarize&#40;mmpg = mean&#40;mpg&#41;&#41; %&gt;% arrange&#40;mmpg&#41;
</code></pre></li><li><strong>User-friendliness</strong>: this is where my opinion of <code>data.table</code> stops being so  positive. The syntax and semantics are based on a rather sound understanding  of how R works, especially lists. A moderately sophisticated piece of  <code>data.table</code> syntax might look like gibberish to a beginner. On the other hand,  the power of <code>dplyr</code> (and also is its main "selling" point) is how the syntax  is, like I said earlier, very English-like in its writing and reading.</li></ul><hr/><p>We're done playing with the basics of <code>data.table</code>! I hope you enjoyed it as much as I did.</p></article></body></html>