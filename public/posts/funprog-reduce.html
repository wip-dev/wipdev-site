<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/hybrid.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/clojure.min.js"></script><link href="/styles.css" rel="stylesheet" /><title>(wipdev-blog)</title></head><body><main><h1>Functional Programming: reduce</h1><p>Continuing the theme of functional programming and <a href='https://en.wikipedia.org/wiki/Higher-order_function#R'>higher-order functions</a>, this one is about another example: <code>reduce</code>. In my <a href='/posts/funprog-map/index.html'>previous post</a>, I wrote about <code>map</code> and its use generally in functional programming and specifically in R. This tutorial will follow a similar structure.</p><p><img src="https://i.imgur.com/bDliPyo.png" alt="reduce" /></p><p>(Image source: <a href='https://iamit.in/blog/Higher-order-functions-in-Python-sorted-map-reduce-filter/'>https://iamit.in/blog/Higher-order-functions-in-Python-sorted-map-reduce-filter/</a>)</p><h2>What is <code>reduce</code>?</h2><p><code>reduce</code> is quite an interesting function. It is sometimes known in other languages as <code>fold</code>. Like <code>map</code> it takes as input a function and a collection (e.g. list). Because this is <i>functional</i> programming, the magic lies in the input function. So, let me describe its behavior and how <code>reduce</code> uses it:</p><ul><li>The function takes two argument. The first is an <i>accumulator</i> (we'll call  it <code>acc</code>), and the second would correspond to an element in the collection  (we'll call it <code>x</code>).</li><li><code>reduce</code> applies that function on each element of the collection in a way  that the result of the first call (on the first element) is used as the  <i>accumulator for the second call</i>, which returns another value to be used  as the <i>accumulator for the third call</i>, and so on... In other words, with  each element in the collection, the accumulator gets updated until a final  value is obtained.</li></ul><p>Unlike <code>map</code>, I believe it is hard to grasp from an abstract point of view without examples, so I will get to that right away.</p><h2>How to implement it in R?</h2><p>Let's start with a simple example. But before starting, I need to point out that the function's name is <code>Reduce&#40;&#41;</code> with a capital R.</p><p>If I want to sum a numeric vector <code>c&#40;1,2,3,4,5&#41;</code> with an algorithm that uses <code>Reduce</code>, the logic is that the accumulator starts at 0, gets added to the first element and 1 becomes the new accumulator. Then, it gets added to the second element and 3 becomes the new accumulator, and so on... So, the function that should be given to <code>Reduce&#40;&#41;</code> takes an accumulator and a (new) element and adds them. You can define that as an anonymous function.</p><pre><code class="r">function&#40;acc, x&#41; {
    acc + x
}
</code></pre><p>After nailing down the function, we can now call <code>Reduce&#40;&#41;</code> with the anonymous function and the vector as arguments.</p><pre><code class="r">Reduce&#40;function&#40;acc, x&#41; {acc + x}, c&#40;1,2,3,4&#41;&#41;
# &#91;1&#93; 10
</code></pre><p>You can think that <code>reduce</code> performs the task like this: <code>&#40;&#40;&#40;1 + 2&#41; + 3&#41; + 4&#41;</code></p><p><strong>Side tip</strong>: you could actually use the plus sign wrapped in backticks &#8216;+&#8216; which means you are using this <a href='https://en.wikipedia.org/wiki/Infix_notation'>infix operator</a> as a function to be passed (e.g. as an argument to <code>Reduce&#40;&#41;</code>).</p><h2>Practical example</h2><p>The previous example was a little bit silly, although you have to get silly sometimes to introduce new concepts based on what you already know and are comfortable with. The next example is a bit more practical. Our goal here is merge two data frames by inserting one data frame <i>at a specific index</i> (i.e. in the middle) of another data frame.</p><p>Consider these example data frames:</p><pre><code class="r">d &lt;- data.frame&#40;A = 1:4, B = c&#40;&quot;AA&quot;, &quot;BB&quot;, &quot;DD&quot;, &quot;EE&quot;&#41;&#41;
to&#95;insert &lt;- data.frame&#40;A = 2.5, B = &quot;CC&quot;&#41;

d$ID &lt;- seq&#40;nrow&#40;d&#41;&#41;
to&#95;insert$ID &lt;- 2.5

d
#   A  B ID
# 1 1 AA  1
# 2 2 BB  2
# 3 3 DD  3
# 4 4 EE  4

to&#95;insert
#     A  B  ID
# 1 2.5 CC 2.5
</code></pre><p>What I want to do is basically insert the data frame <code>to&#95;insert</code> between row 2 and row 3 of the data frame <code>d</code>. There are two main things that need to be done to get a <code>Reduce&#40;&#41;</code> algorithm ready.</p><h3>Make a list out of the data frame</h3><p><code>Reduce&#40;&#41;</code> need a collection to iterate (and accumulate) over. In this case, we need to build a "collection of rows". This is easily done with the function <code>split&#40;&#41;</code>.</p><pre><code class="r">d&#95;split &lt;- split&#40;d, d$ID&#41;
d&#95;split
# $`1`
#   A  B ID
# 1 1 AA  1
#
# $`2`
#   A  B ID
# 2 2 BB  2
#
# $`3`
#   A  B ID
# 3 3 DD  3
#
# $`4`
#   A  B ID
# 4 4 EE  4
#
</code></pre><p>That takes care of one argument.</p><h3>Build the accumulating function</h3><p>The accumulation in the previous example was done by addition. But in this example, accumulation is actually row-binding. So, the accumulator will be a data frame, and I will keep adding the rows of the list to that accumulator <i>until I've reached the index of interest</i>, in which case I will also _bind the data frame I want to insert_ before continuing the accumulation process.</p><pre><code class="r">fn &lt;- function&#40;acc, row&#41; {

  if &#40;row$ID == 2&#41; {
    rbind&#40;acc, row, to&#95;insert&#41;
  } else {
    rbind&#40;acc, row&#41;
  }

}
</code></pre><h3>Putting it together</h3><p>The final step is merely calling <code>Reduce&#40;&#41;</code> with the pieces we built.</p><pre><code class="r">Reduce&#40;fn, d&#95;split&#41;
#      A  B  ID
# 1  1.0 AA 1.0
# 2  2.0 BB 2.0
# 11 2.5 CC 2.5
# 3  3.0 DD 3.0
# 4  4.0 EE 4.0
</code></pre><p>From there, you could easily work your way forward by abstracting this algorithm into a function, or maybe adjust the row names.</p><hr/><p>That's it for <code>reduce</code>! Another interesting functional programming concept, and R already has it built in.</p><p>P.S. The last example was inspired from <a href='https://www.linkedin.com/posts/adrianolszewski_rockyourr-statistics-datascience-activity-6709076931184259072-_A5y'>a LinkedIn post by Adrian Olszewski</a> in which he used a similar implementation but with <code>do.call&#40;&#41;</code> instead of <code>Reduce&#40;&#41;</code>.</p></main><aside><pre id="logo"><code>(wipdev-blog)</code></pre><ul><li><a href="/">Home/About</a></li><li><a href="/posts">Articles</a></li><li><a href="https://github.com/wipdev-tech" target="_blank">GitHub</a></li></ul></aside><script src="/main.js"></script></body></html>