<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/hybrid.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/clojure.min.js"></script><link href="/styles.css" rel="stylesheet" /><title>(wipdev-blog)</title></head><body><main><h1>Functional Programming: filter</h1><p>Another famous higher-order function is <code>filter</code>. Although it is rather handy for some programming languages, it might be less useful in the R world. I will talk about it for the sake of completeness (I wrote two posts about higher-order functions: <a href='/posts/funprog-map/'>one about map</a> and <a href='/posts/funprog-reduce/'>another about reduce</a>). Then I will explain why we don't need it in R</p><h2>What is <code>filter</code>?</h2><p>Like the other higher-order functions we talked about, <code>filter</code> takes a function and a collection. The result is a subset of the original collection. Elements are kept or discarded, not surprisingly, according to the input function:</p><ul><li>The input function takes an element of the collection and produces a  boolean/logical, which is called a <i>predicate</i>.</li><li>For each element of the collection, the predicate is called. If the  predicate returns <code>TRUE</code> the element is kept, and if it returns <code>FALSE</code>  (you guessed it) the element is discarded.</li></ul><h2>How to implement it in R?</h2><p>If you already know <a href='/posts/funprog-map/'>map</a> and <a href='/posts/funprog-reduce/'>reduce</a>, <code>filter</code> should be very easy. It is available in base R with a capital F: <code>Filter&#40;&#41;</code>.</p><p>Let's say you have a vector <code>c&#40;1,2,3,4,5&#41;</code> and you want to filter only even numbers. The only trick you need to do is build a predicate, which we'll call <code>is&#95;even&#40;&#41;</code>.</p><pre><code class="r">is&#95;even &lt;- function&#40;x&#41; {
    x %% 2 == 0
}
</code></pre><p>All what's left is calling <code>Reduce&#40;&#41;</code> with the predicate and the vector.</p><pre><code class="r">Filter&#40;is&#95;even, 1:5&#41;
# &#91;1&#93; 2 4
</code></pre><h3>Side note: negating a predicate</h3><p>Although you could easily negate a logical vector with the exclamation/bang sign, that doesn't make sense for a predicate: you can't negate a function. But R has a built-in function called <code>Negate&#40;&#41;</code> that takes a predicate and return another predicate with the logic flipped. (Notice that this is a higher-order function that is different from the ones we discussed because it <i>returns</i> a function, the new predicate.)</p><h2>Why is it not very useful?</h2><p>One word: <i>vectorization</i>.</p><p>In case you don't know what that means, it is the fact that when you do an arithmetic or logical operation on a vector. R automatically does it element-wise. This is not the default behavior of most programming languages in which it doesn't make sense to add a number to a collection. But R is a language "made by statisticians for statisticians", and making vectorization a default behavior is (I think) a smart move for a language meant to be used by non-developers.</p><p>So, when I ask if the remainder of dividing "the vector" by two is zero, I get back a vector of <code>TRUE</code>s and <code>FALSE</code>s.</p><pre><code class="r">1:5 %% 2 == 0
# &#91;1&#93; FALSE  TRUE FALSE  TRUE FALSE
</code></pre><p>Which brings us to the second smart move: any vector can be indexed with logical vectors, so that values matching the <code>TRUE</code>s are kept and those matching the <code>FALSE</code>s are discarded.</p><p>Here is another example in which I will write both methods without any intermediate definitions, and it's up to you to decide which is better to your taste.</p><pre><code class="r">Filter&#40;function&#40;x&#41; x %% 1 == 0, iris$Sepal.Length&#41;
#  &#91;1&#93; 5 5 5 5 5 5 5 5 7 5 6 6 6 6 5 6 6

iris$Sepal.Length&#91;iris$Sepal.Length %% 1 == 0&#93;
#  &#91;1&#93; 5 5 5 5 5 5 5 5 7 5 6 6 6 6 5 6 6
</code></pre><p>Personally, I feel slightly annoyed by the need to repeat the vector's name to use the indexing-based method. But I also know that these higher-order functions are kind of obscure in the R world.</p><p>Let's also not forget that R is meant for data analysis, and <code>Filter&#40;&#41;</code> doesn't work with data frames unless you convert them to a list. But why do that when you have indexing-based filtering? or <code>dplyr</code>?</p><hr/><p>That ends our glance over the higher-order <code>filter</code> and, more importantly, why R programmers don't need it.</p></main><script src="/main.js"></script></body></html>