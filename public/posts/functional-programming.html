<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/hybrid.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/clojure.min.js"></script><link href="/styles.css" rel="stylesheet" /><title>(wipdev-blog)</title></head><body><main><h1>Functional Programming</h1><p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1691853775339/3b697a52-9efc-400d-8487-71562a9b588f.png?w=1600&h=840&fit=crop&crop=entropy&auto=compress,format&format=webp" alt="cover" /></p><p>After I <a href='/posts/clojure-as-a-lisp.html'>discussed the uniqueness of Clojure being a Lisp</a>, this article will go into the other obvious difference between Clojure and JavaScript, which is that Clojure is a more functional language than JS. I am saying "more functional" because I don't think of it as a binary classification. Functional programming can be done in both languages, but Clojure supports it to a greater extent.</p><p>This topic gets discussed a lot when introducing functional languages like Clojure or FP-inspired features in other languages, like high-order array methods in JS. I will recap most of that info here and add my two cents.</p><h2>Functions as First-Class Citizens</h2><p>It's literally in the name! In FP, you write most (or all) of your code as functions. The functions could operate directly on data or be composed together to produce larger functions. That brings us to the concept of high-order functions, which are functions that take functions as arguments and/or return functions as output. That ties in with many concepts like composition, partial application, currying, etc.</p><p>I will take function composition as an example using the Clojure code below.</p><pre><code class="clojure">&#40;defn prob-&gt;odds
  &#91;prob&#93;
  &#40;/ prob &#40;- 1 prob&#41;&#41;&#41;

&#40;def logit &#40;comp clojure.math/log prob-&gt;odds&#41;&#41;
</code></pre><p>The first part defines a function that converts a probability to odds. For example, a probability of 0.25 (25%) is 0.25:0.75 odds, so 1:3 or ~0.3333. Next, I compose the functions <code>clojure.math/log</code> (the natural log) and the function I wrote first to yield my own implementation of the <a href='https://en.wikipedia.org/wiki/Logit'>logit (log odds) function</a>. This way of composing and defining <code>logit</code> is known as "point-free style" because I didn't need to specify a parameter. I directly operated on functions to yield another function. This is similar to the mathematical representation <em>h = f âˆ˜ g</em> which corresponds to <em>h(x) = f(g(x))</em>.</p><p>In JavaScript, you can write functions and pass them as values. There are also implementations of high-order functions as array methods. However, there is no way to directly compose them as far as I know. The answer to something like this would usually be to implement <code>comp</code> in JS. I believe it would be done with something like this:</p><pre><code class="javascript">// Using Recursion
function comp&#40;fns&#41; {
    if &#40;fns.length === 0&#41; {
        return &#40;x&#41; =&gt; x
    } else {
        return &#40;x&#41; =&gt; fns&#91;0&#93;&#40;comp&#40;fns.slice&#40;1&#41;&#41;&#40;x&#41;&#41;
    }
}

// Using Reduce
function comp2&#40;fns&#41; {
    return fns.reverse&#40;&#41;.reduce&#40;&#40;compFn, nextFn&#41; =&gt; {
        return &#40;x&#41; =&gt; nextFn&#40;compFn&#40;x&#41;&#41;
    }, &#40;x&#41; =&gt; x&#41;
}
</code></pre><p>A problem with something like this is that it works only with functions that are called directly with values as arguments (more on that later). In other words, we can't compose object methods. Also, the lack of the point-free style makes it a bit more verbose and less elegant.</p><p>Another important characteristic of functions in FP is that they are preferred to be <em>pure</em>. The meaning of functional purity is that a function must give the same output every time it takes the same input (it's also called <em>referential transparency</em> if you're feeling sophisticated). It does not rely on the "outer world" or change it in the process. Of course, at some point, you will have to make a <em>side effect</em> like interacting with databases or changing the DOM, but FP encourages minimizing and isolating such behavior while keeping the majority of the functions pure for simplicity and predictability. Clojure specifically is one of the functional languages that are pragmatic about side effects, unlike a language like Haskell which has stronger enforcement of functional purity.</p><h2>Abstraction</h2><p>One problem I find with FP in JS is that you cannot really escape the "object-orientedness" of it. Popular FP features like <code>map</code> and <code>reduce</code> are implemented as array methods. One issue is that the syntax is not consistent: there is <code>function&#40;args&#41;</code>, and there is <code>object.method&#40;args&#41;</code>, and the latter is much more common. You can chain methods but that depends on their return types. Extending an object prototype with new methods is non-idiomatic and generally discouraged in JS, and writing top-level functions breaks the method pattern.</p><p>Methods are JS' (or rather OOP's) way of associating a group of functions with certain data structures. Clojure has, in my humble opinion, a more elegant way of doing that. It has the notion of <em>abstractions</em> in the sense that if a data structure falls under one abstraction, then a certain group of functions can be called on that data structure. For example, there is the sequence abstraction which applies to stuff like vectors, lists, hash-maps, etc. That means that a family of functions like <code>map</code> and <code>filter</code> can be used with these data structures. Using this approach, the language ends up with a uniform way of writing code for similar data structures, plus some interesting language features like using keywords as functions to get a corresponding value from a map.</p><pre><code class="clojure">&#40;def person {:name &quot;John&quot; :age 32}&#41; 

;; Keywords can be called like functions
&#40;ifn? :anykeyword&#41;   ; true
&#40;:name person&#41;       ; &quot;John&quot;
&#40;:hair-color person&#41; ; nil
</code></pre><h2>Immutable Data Structures</h2><p>As pointed out earlier, pure functions are free from side effects. One side effect that's worth its own discussion is mutating data structures. Programming is fundamentally about processing data, and the common languages we use today usually do this by modifying an existing data structure in place (like filtering an array or modifying a property of an object). In FP, functions do their jobs by returning a modified copy, leaving the original object intact. An obvious problem is the inefficient copying of objects, and this is where immutable data structures come into play.</p><p>Immutable/persistent data structures are implemented in functional languages like Clojure with the so-called <em>structural sharing</em>. My intuitive understanding of it is that the modified "copy" actually shares data with the original structure. This is possible because they are immutable and can always be used as a reference for future modified copies. You get that out of the box with Clojure but not JS as far as I know.</p><h2>Lazy Evaluation</h2><p>That's another feature commonly seen in FP. It means that expressions are evaluated only when needed. This means that some functions will partially evaluate a vector and return when its job is done without going through every value. It also means that you can make infinite vectors!</p><p>Take this code for example:</p><pre><code class="clojure">&#40;take 10 &#40;range&#41;&#41;
</code></pre><p>The <code>range</code> function when called with no arguments gives an infinite sequence of integers starting from 0, and <code>take</code> with 10 as an argument subsets the first 10 elements of the vector. Instead of returning an error or running forever, the expression simply evaluates the needed part of the "infinite" vector and returns 10 numbers. This has some obvious efficiency gains, but I find it pretty cool in general!</p><h2>Conclusion</h2><p>You can implement almost any concept in any language, but we can't deny that a certain language usually makes some paradigms easier to work with than others. This is why in JS you'd either use the functional stuff you're given by the language as-is, or you'd have to put the time and effort (or libraries) to implement functional features that aren't built in.</p><p>On a final note, I like FP. It always feels simpler and more intuitive for me than OOP. Functions are kind of a universal concept that I saw in math and Excel before I saw it in programming. In contrast, a particular object class and its methods form a special world of their own that you need to understand before interacting with them. My personal story with FP is the topic of a separate article, but at the time of writing this, I am still going strong with learning FP and Clojure in particular.</p><p>And that ends my piece, I hope It gave you a good overview of FP concepts.</p><hr/><p>Cover images source: <a href='https://www.qulix.com/uncategorized/functional-programming/'>https://www.qulix.com/uncategorized/functional-programming/</a></p></main><aside><pre id="logo"><code>(wipdev-blog)</code></pre><ul><li><a href="/">Home/About</a></li><li><a href="/posts">Articles</a></li><li><a href="https://github.com/wipdev-tech" target="_blank">GitHub</a></li></ul></aside><script src="/main.js"></script></body></html>