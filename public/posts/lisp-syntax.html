<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/hybrid.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/clojure.min.js"></script><link href="/styles.css" rel="stylesheet" /><title>(wipdev-blog)</title></head><body><main><h1>The Weird and Interesting Lisp Syntax</h1><p>As I go through the course <a href='https://www.coursera.org/learn/programming-languages-part-b/'>Programming Languages Part B</a>, which teaches programming concepts on the language Racket, let me reflect on the strange syntax of Lisp (on which Racket is based).</p><p><img src="https://imgs.xkcd.com/comics/lisp_cycles.png" alt="lisp-cycle" /></p><p>(Image source: <a href='https://xkcd.com/297/'>https://xkcd.com/297/</a>)</p><h2>Lisp? Racket?</h2><p>I see that in a world full of Python and JavaScript, Racket and other Lisp "dialects" are kind of obscure nowadays. <a href='https://en.wikipedia.org/wiki/Racket_(programming_language'>Racket</a>) is a (mainly) functional language, but I am here not to talk about its paradigm.</p><p>Racket's syntax is all about parentheses! Something like simple arithmetic should be written like this in any common language:</p><pre><code class="r">1 + 2 &#42; 3 &#94; 4
</code></pre><p>That would be actually written in Racket like this:</p><pre><code class="racket">&#40;+ 1 &#40;&#42; 2 &#40;expt 3 4&#41;&#41;&#41;
</code></pre><p>This does what you'd expect from the first line of code, and as we learn in any basic programming course, nesting works from the inside out: <code>expt</code> is run first to give us 3 to the 4 which is then multiplied by 2 then added to 1.</p><p>That's too many parentheses already! But you should notice that the order of symbols is different. This is because the arithmetic operators are <i>prefix</i> functions which are called by putting them <i>inside</i> parentheses: <code>&#40;function arg1 arg2 ...&#41;</code> which is a bit different. Notice that this makes parentheses an obligatory part of the syntax and not just to group things together.</p><p>Let's take things up a level and see a piece of code that corresponds to a variable definition and multi-branch if expression that uses that variable.</p><pre><code class="racket">&#40;define x 10&#41;
&#40;cond
  &#40;&#40;&lt; x 10&#41; &quot;x is smaller than 10&quot;&#41;
  &#40;&#40;&gt; x 10&#41; &quot;x is greater than 10&quot;&#41;
  &#40;#t &quot;x is exactly 10&quot;&#41;&#41;
</code></pre><p>Again, the parentheses nest everything. Even variable definitions are done with functions inside parentheses. You can see the form `(cond (b1 e1) (b2 e2) ...)<code> in which </code>bi` is a boolean or an expression that evaluates to a boolean, and <code>ei</code> is the expression that is run when a branch is true (all of which are strings here).</p><p>Actually, just for better readability, any pair of parentheses can be replaced by square brackets. This is commonly used to enclose <code>cond</code> branches. So, we can rewrite the previous expression like this (I also added whitespace to make it look like a table):</p><pre><code class="racket">&#40;cond
  &#91;&#40;&lt; x 10&#41; &quot;x is smaller than 10&quot;&#93;
  &#91;&#40;&gt; x 10&#41; &quot;x is greater than 10&quot;&#93;
  &#91;#t       &quot;x is exactly 10&quot;&#93;&#41;
</code></pre><p>As a final example, here is a function definition that uses <code>map</code> which takes an anonymous function and a list of strings. The anonymous functions appends a suffix at the end of each string.</p><p><strong>Note</strong>: If you don't know about <code>map</code> and anonymous functions, check out <a href='/posts/funprog-map/'>my <code>map</code> tutorial</a> in which I explain these concepts and their applications in R.</p><pre><code class="racket">&#40;define &#40;string-append-map xs suffix&#41;
  &#40;map &#40;lambda &#40;x&#41; &#40;string-append x suffix&#41;&#41; xs&#41;&#41;
</code></pre><h2>Why the syntax is interesting</h2><p>Having parentheses for everything makes the syntax initially confusing. There are no (infix) operators or any other forms of special syntax that make pieces of code more or less distinguishable. But there is actually a couple of benefits to that syntax.</p><h3>It is minimal</h3><p>I am going to paraphrase the course instructor, Dan Grossman, here: the syntax is so simple it can fit on one slide. Instead of having special syntax for every construct (e.g. variable/function definitions, if/else statements, function calls, etc.), Racket has most of its constructs as functions or special forms that have almost identical syntax.</p><h3>It is unambiguous</h3><p>In the arithmetic code written earlier, you need to remember how the operations are ordered to code it correctly. A lot of syntax rules in programming languages are like this. For example, the pipe operator in R might not work the way you expect it when there are other operators before it. (Try to work out which of e2 or e3 is equivalent to e1 in this piece of code.)</p><pre><code class="r">1 + 2 %&gt;% exp&#40;&#41;    # e1
1 + &#40;2 %&gt;% exp&#40;&#41;&#41;  # e2
&#40;1 + 2&#41; %&gt;% exp&#40;&#41;  # e3
</code></pre><p>In Racket, however, the simple syntax leads to having only one way to do things: every operator/function is prefix and you can nest them as deep as you want because everything is already enclosed in parentheses.</p><hr/><p>Remember that opinions towards syntax are just opinions: they are subjective. I do like that syntax and enjoy programming with it in the course. I am not sure if I would ever get to use a Lisp dialect in a "real" application, but that would be fun.</p></main><aside><pre id="logo"><code>(wipdev-blog)</code></pre><ul><li><a href="/">Home/About</a></li><li><a href="/posts">Articles</a></li></ul></aside><script src="/main.js"></script></body></html>