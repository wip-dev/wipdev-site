<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/hybrid.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/clojure.min.js"></script><link href="/styles.css" rel="stylesheet" /><title>(wipdev-blog)</title></head><body><main><h1>Standard Library</h1><p><img src="https://i.imgur.com/nhBxOOc.png" alt="cover" /></p><p>In this article, I will explore what I learned in Clojure's standard library in comparison to JavaScript's. Without trying to get the most precise definition of "standard library," for the sake of this discussion, I mean things that you can do with the base distribution of the language. This article in particular will discuss basic stuff that should be applicable regardless of the environment or runtime. What I say about Clojure applies to ClojureScript, and what I say about JS applies to the browser and Node.</p><p>Without further ado, let's get into it.</p><h2>Why Care About Standard Libraries?</h2><p>Relying more on a standard library means relying less on (external) dependencies. So, in a world where everyone just <code>npm install</code>s anything and everything, allow me to go a bit over why standard libraries matter. I wrote a full article, <a href='/posts/dependencyphobia.html'>Dependencyphobia</a>, going over why I have issues with dependencies, but I'll give a quick summary of them here:</p><ul><li>They add more chance of the occurrence of bugs or incompatibility between separate libraries.    </li><li>They have a higher risk of deprecation and breaking changes than standard library features.    </li><li>Relying on high levels of abstraction like frameworks makes your code, and possibly your knowledge and skills, non-transferable. In other words, you can't take what you learned in one framework and apply it directly in another.    </li></ul><p>Simply, the fewer dependencies you have in your project, the more robust and future-proof your project becomes. To be able to achieve this, you need the support of a rich standard library that allows you to do things with ease so that you don't need to reach for an external library.</p><h2>Data Structures</h2><p>On the surface, the data structures I was exposed to so far are very similar in spirit (more on that in a bit) to those commonly used in JS. You get primitive data types like numbers, strings, and booleans, but one special data structure is the keyword which is most commonly used for "keys" in key-value pairs. For collections, you get vectors which are like JS arrays in the sense that they are ordered collections and can hold data that have different types, i.e., heterogenous. There are also hash maps which are like JS objects in the sense that they store key-value pairs.</p><p>I said that they are similar "in spirit" because these Clojure data structures are persistent (immutable), and that is a totally different behavior from JS where objects are mutable even when defined with the <code>const</code> keyword. Immutable data structures are one of the core features of functional programming, and I wrote an <a href='/posts/functional-programming.html'>article discussing some FP features</a> in a bit more detail if you're interested. So in that sense, the similarities lie mostly in their practical use and not the underlying data structure implementation.</p><p>On a final note, Clojure has more data structures I didn't mention like lists, hash sets, sorted sets (which I never used so far), and lazy sequences. What I like about the language's design here is that these data structures are categorized into abstractions like "sequences" and "collections," and that determines which functions you can use with them. I discussed this in a little more detail in contrast to the typical OOP approach in the same article linked above.</p><h2>Functions and Composition</h2><p>The variety of functions provided by the core library (<code>clojure.core</code>) is the biggest reason for writing this article. A huge number of ways in which you would want to manipulate data are already implemented for you in standard library functions. This is great because most of your needs are already covered, and if not, they can be done by composing a small number of these functions. Note that I don't mean composing strictly as in "function composition" but rather the general idea of combining functions together. The result is code that is much more declarative than JS, and it's also more concise and clean (when you get over the parentheses).</p><p>Now let me share some examples of cool stuff I learned, I'll share some functions that I've got from exercises I solved in <a href='http://4clojure.oxal.org/'>4clojure</a> plus some functions and features I discovered outside of the context of a specific problem. They helped me discover and appreciate Clojure's standard library and how I can compose functions together to write declarative and concise code.</p><h3>Default Map</h3><pre><code class="clojure">&#40;defn default-map
  &#91;val keys&#93;
  &#40;zipmap keys &#40;repeat val&#41;&#41;&#41;

&#40;default-map 0 &#91;:a :b :c&#93;&#41; ; {:a 0, :b 0, :c 0}
</code></pre><p>The task here was to make a function that takes a value and a vector of keys as its arguments, and its job is to construct a map where each key maps to this "default" value. Here's how the function works.</p><ul><li><code>repeat</code> is a function that generates an infinite (lazy) sequence of the same value. In case you don't know, lazy sequences can be infinite because they only evaluate as needed, which will happen below.    </li><li><code>zipmap</code> takes two sequences - one for keys and one for values - and constructs a map by associating the first key with the first value, the second key with the second value, etc.    </li><li>The advantage of combining the two is that <code>zipmap</code> will stop when it runs out with either keys or values. So, from the "infinite" values, Clojure will only get as many as the number of keys.    </li></ul><h3>Pack a Sequence</h3><pre><code class="clojure">&#40;defn pack
  &#91;seq&#93;
  &#40;partition-by identity seq&#41;&#41;

&#40;pack &#91;1 1 1 2 3 3 4&#93;&#41; ; &#40;&#40;1 1 1&#41; &#40;2&#41; &#40;3 3&#41; &#40;4&#41;&#41;
</code></pre><p>This code is meant to take a sequence and "pack" each set of consecutive duplicates into a separate sequence. Thankfully, there is a function called <code>partition-by</code> which, as the name indicates, partitions sequences by something. That "something" should be a function, and here we supply <code>identity</code> which means we partition by values whose identities (the values themselves) are equal to each other. There's also another function called <code>partition</code> which splits a sequence based on a fixed number of elements.</p><h3>Dot Product</h3><pre><code class="clojure">&#40;defn dot-product
  &#91;c1 c2&#93;
  &#40;apply + &#40;map &#42; c1 c2&#41;&#41;&#41;

&#40;dot-product &#91;1 2 3&#93; &#91;0 10 100&#93;&#41; ; 320
</code></pre><p>As per Wikipedia, <em>"Algebraically, the dot product is the sum of the products of the corresponding entries of the two sequences of numbers."</em> So the code works like this:</p><ul><li><code>&#40;map &#42; c1 c2&#41;</code> takes the two collections and applies the multiplication function on each pair, returning the vector <code>&#91;0, 20, 300&#93;</code>.    </li><li><code>apply</code> is similar to the spread (<code>...</code>) operator in JS where you supply a collection and its elements are supplied as arguments. So, <code>+</code> in the example takes 3 arguments: 0, 20, and 300 (instead of the whole vector as a single argument).    </li></ul><p>I have a lot more examples like these to share, but I don't want to do too much cherry-picking of all the cool one-liners that I wrote or found online.</p><h3>Other Conveniences</h3><p>There are other functions and conveniences that I learned about and find to be quite nice to help perform common tasks with a small amount of code.</p><ul><li>Maps can be called as functions for lookup, so <code>&#40;{:a 1 :b 2} :a&#41;</code> will return 1. Also, keywords can be called as lookup functions, so <code>&#40;:a {:a 1 :b 2}&#41;</code> also works.    </li><li>Sets can be called as predicates, so <code>&#40;filter #{1 2} &#91;2 5 4 3 9&#93;&#41;</code> looks for 1 or 2 in the vector, returning the list <code>&#40;2&#41;</code>.    </li><li><code>complement</code> can be called on a predicate (a function that returns a boolean) and returns the "complement" function which returns the opposite boolean.    </li><li>There is a concise syntax for anonymous functions. For example, <code>#&#40;map &#42; %1 %2&#41;</code> is an anonymous function that calls <code>map</code> to apply the multiplication function on two arguments (you see, <code>%1</code> and <code>%2</code> specify the arguments at which positions without having to name them.) Notice that <code>map</code> here accepts whatever number of arguments that work for the function, which is convenient.    </li><li>Arithmetic and comparison functions can take arbitrary numbers of arguments, so the plus can act as a sum, and the greater-than/less-than functions work on the arguments consecutively, so <code>&#40;&lt;= 1 2 2 4&#41;</code> returns <code>true</code>.    </li><li>Threading macros are a convenient way to pipe the output of one function into the next one as an argument, so the code can be read top-to-bottom instead of the nested syntax. For example, here is a refactor of the <code>default-map</code> function above to use the threading macro <code>-&gt;&gt;</code> which piped an output as the last argument in the next function.    </li></ul><pre><code class="clojure">&#40;defn default-map
  &#91;val keys&#93;
  &#40;-&gt;&gt; val
       repeat
       &#40;zipmap keys&#41;&#41;&#41;
</code></pre><p>The language is full of cool stuff like this. So, there is so much you can do without having to reach out to a library when it comes to handling and manipulating data. In JavaScript, I would've had to make a custom function and pass it to <code>array.map&#40;&#41;</code> or <code>array.reduce&#40;&#41;</code>, and then things get too complex so I split it into multiple <code>map</code>/<code>reduce</code> calls and create some intermediate arrays. When you compare this approach to Clojure's, it feels wasteful, especially when the code becomes more verbose and imperative and you have to re-read the whole thing if you want to check how that particular step works.</p><p>You may argue against Clojure because it's too dense and you have function names in front of you that you don't know what each one does. First, with practice, these little idioms become easy to understand - Difficulty is simply a matter of unfamiliarity in most situations. Also, and most importantly, Clojure is a very well-documented language. <a href='https://clojuredocs.org/'>https://clojuredocs.org/</a> is a community-powered site with good examples and it's my favorite source of documentation. These documentation pages are also accessible from my editor thanks to <a href='https://clojure-lsp.io/'>Clojure LSP</a>, which is even more convenient.</p><p><img src="https://i.imgur.com/f0HGnxH.png" alt="interleave clojuredocs" /></p><p><img src="https://i.imgur.com/5Yrw2z8.png" alt="interleave lsp" /></p><h2>There's More</h2><p>There always is! This article was mainly concerned with a small subset of <code>clojure.core</code> functions whose main job is to manipulate data. There is a whole world of stuff related to concurrent programming and mutable state that I am still learning at the moment, and that should be interesting to compare and contrast with JavaScript's concurrency model.</p></main><aside><pre><code>(wipdev-blog)</code></pre><ul><li><a href="/">Home/About</a></li><li><a href="/posts">Articles</a></li></ul></aside><script src="/main.js"></script></body></html>