<!DOCTYPE html><html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/tokyo-night-dark.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/clojure.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/js.min.js"></script><link href="/styles.css" rel="stylesheet" /></head><body><article><h1>Programming Languages, Part A: Best MOOC Ever?</h1><p>I took so many MOOCs over the past three years (I lost count but they gotta be around 30), but this one was <i>the hardest</i> in terms of content, homeworks, and quizzes... but also the most fun! It is actually <a href='https://www.coursera.org/learn/programming-languages'>the first part of a conceptually 3-part course</a>, and I am not exaggerating in saying that this is the best MOOC I ever took, because I thoroughly enjoyed every part of it, and I can't wait to take the other parts.</p><p>The following is a relatively quick review of what this course is about (I will use "the course" to refer to part A that I actually took and finished). Each section is either one of the course's general goals or one of my own observations about it.</p><h2>Language choice</h2><p>The instructor Dan Grossman (who is a great teacher, by the way) made it very clear that his language choices depend on the suitability of the language as a vehicle for introducing the programming concepts he wants to teach, and they are:</p><ul><li><strong>Standard ML</strong> for part A</li><li><strong>Racket</strong> for part B</li><li><strong>Ruby</strong> for part C</li></ul><p>From what I know about popular languages, I think SML would feel <i>really</i> weird for anyone used to such languages, but not so much for those used to functional languages. I say this because I tried a little bit of Haskell on my own and found those two languages to be similar to each other than any other language I tried, including R, Python, and JavaScript.</p><p>Here is an implementation of the popular functions <code>map&#40;&#41;</code> and <code>filter&#40;&#41;</code> in SML:</p><pre><code class="sml">fun map &#40;f,xs&#41; =
    case xs of
        &#91;&#93;     =&gt; &#91;&#93;
      | x::xs' =&gt; &#40;f x&#41;::map&#40;f,xs'&#41;;

fun filter &#40;f,xs&#41; =
    case xs of
        &#91;&#93;     =&gt; &#91;&#93;
      | x::xs' =&gt; if &#40;f x&#41;
                  then x::filter&#40;f,xs'&#41;
                  else filter&#40;f,xs'&#41;;
</code></pre><h2>Functional programming</h2><p>This course, and the next one, has a huge focus on concepts that belong to functional programming (FP) or at least close to it. Things like recursion, pattern matching, higher-order functions, and closures take up a huge part of the course and associated homeworks. In between this big concepts, there are small tips about performance, style, and other odds and ends that glue these things together.</p><p>I find this paradigm very interesting because I come mainly from the R world, which is a bit of a hybrid between functional and other paradigms that allow mutation. When I learned Python, I found the concept of mutation (especially methods that modify the object in place and return <code>None</code>) kind of annoying. So, I already gravitate toward learning more FP.</p><h2>Not too theoretical; not too pragmatic</h2><p>Most programming MOOCs and tutorials out there fall into two categories:</p><ol><li>The theoretical kind, like an academic data structures & algorithms course   in a computer science degree program. (I never took any of those.)</li><li>The practical, "let's build something" kind (which is obviously taking   over the internet).</li></ol><p>This course is surprisingly in the middle! It doesn't let you build something practical like a small app or a game, but it also doesn't get too heavy with theory and notation. I might say it has just the right amount of either side.</p><h2>Challenging & rewarding</h2><p>This is literally stated at the welcome notes of the course, and I wholeheartedly agree! The course material is dense and requires serious focus to understand the concepts if they are new. There are 3 homework assignments. Each contains roughly 10-15 coding problems to solve where the solution could be a one-liner or as long as 15-20 lines. There is also a final exam which is longer (and obviously harder) than your average Coursera "quiz".</p><p>In short, this course will get you to <i>think</i>, and if you are like me, you will definitely enjoy that.</p><hr/><p>As someone with huge interest in learning programming, I found this course so informative and fun, and I hope this review encourages other programmers to take it. Of course, I am looking forward to starting the second part of the course on Racket. (Oh, Lisp...)</p></article><script src="/main.js"></script></body></html>